---
layout:     notebook
title:      动态规划
author:     TangYuanqing
tags: 		ACM 动态规划 HDU
subtitle:   01背包问题 HDU-2546饭卡
category:  ACM Log

notebookfilename:
visualworkflow: false
---
# 01背包问题
![Question](https://github.com/TangYuanqing/TangYuanqing.github.io/tree/master/img/01bag.png)
{% highlight cpp %}
#include <iostream>

#include <cstring>

#include <cstdio>

#include <algorithm>

#include <iomanip>

using namespace std;

int dp[10000];
int main()
{
  freopen("01bag.in","r",stdin);
  int n,V;
  int w[1000],v[1000];
  cin >> n >> V;
  cout.flags(ios::left);
  memset(dp,0,sizeof(dp));
  for(int i=1;i<=n;i++)cin>>w[i]>>v[i];
  for(int i=1;i<=n;i++)
    for(int j=V;j>=1;j--)
      {
        if(j>=w[i])dp[j]=max(dp[j],dp[j-w[i]]+v[i]);
        // for(int i=1;i<=V;i++)
        //   cout << setw(3) << dp[i] << " " ;
        // cout << endl;
      }
    cout << dp[V] << endl;
  return 0;
}
{% endhighlight %}

#### Problem Description
电子科大本部食堂的饭卡有一种很诡异的设计，即在购买之前判断余额。如果购买一个商品之前，卡上的剩余金额大于或等于5元，就一定可以购买成功（即使购买后卡上余额为负），否则无法购买（即使金额足够）。所以大家都希望尽量使卡上的余额最少。
某天，食堂中有n种菜出售，每种菜可购买一次。已知每种菜的价格以及卡上的余额，问最少可使卡上的余额为多少。


#### Input
多组数据。对于每组数据：
第一行为正整数n，表示菜的数量。n<=1000。
第二行包括n个正整数，表示每种菜的价格。价格不超过50。
第三行包括一个正整数m，表示卡上的余额。m<=1000。

n=0表示数据结束。


#### Output
对于每组输入,输出一行,包含一个整数，表示卡上可能的最小余额。


#### Sample Input
1
50
5
10
1 2 3 2 1 1 2 3 2 1
50
0


#### Sample Output
-45
32
